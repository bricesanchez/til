<!DOCTYPE html><html><head><meta charset="utf-8" /><title>Blog — Today Icelab Learnt</title><link href="/assets/public.css" rel="stylesheet" type="text/css" /><script src="/assets/public.js" type="text/javascript"></script></head><body><h1><a href="/">Today Icelab Learnt</a></h1><div class="blog"><h1><a href="/creating-an-iam-user-for-s3-bucket/">Creating an IAM user for access to an S3 bucket</a></h1><div class="content" data-view-highlight=""><p>When you create an S3 bucket for a web app to use, you should create a specific IAM user to grant access to that bucket.</p>

<p>To do this, first create a user:</p>

<ol>
<li>Visit the <a href="https://console.aws.amazon.com/iam">IAM section of the AWS console</a></li>
<li>Go to the &ldquo;Users&rdquo; section and click the &ldquo;Create New Users&rdquo; button</li>
<li>Enter the user name(s) you want to create (e.g. <code>my-bucket-s3</code> for a bucket named <code>my-bucket</code>)</li>
<li>When you&rsquo;re shown the user credentials, save them somewhere safe, like our team 1Password vault</li>
<li>When you return to the IAM users list, go to the newly created user and click on their &ldquo;Permissions&rdquo; tab. Click on the &ldquo;Inline Policies&rdquo; section and create a new policy</li>
<li>Choose to create a &ldquo;Custom Policy&rdquo;</li>
<li><p>Name the policy &ldquo;my-bucket-s3-access&rdquo; (or something similarly descriptive) and paste the following into the &ldquo;Policy Document&rdquo; area (replacing <code>my-bucket</code> with your bucket&rsquo;s name):</p>

<pre><code class="json">{
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: &quot;s3:ListAllMyBuckets&quot;,
      &quot;Resource&quot;: &quot;arn:aws:s3:::*&quot;
    },
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: &quot;s3:*&quot;,
      &quot;Resource&quot;: [
        &quot;arn:aws:s3:::my-bucket&quot;,
        &quot;arn:aws:s3:::my-bucket/*&quot;
      ]
    }
  ]
}
</code></pre></li>
<li><p>Click &ldquo;Apply Policy&rdquo;</p></li>
</ol>

<p>The access policy should now be active and your app should be able to access the bucket with the new IAM user&rsquo;s credentials.</p>
</div><div class="tags"><a href="/tags/aws">aws</a></div><h1><a href="/chrome-vox/">ChromeVox</a></h1><div class="content" data-view-highlight=""><p><a href="http://www.chromevox.com/">ChromeVox</a> is a screen reader extension for Chrome.</p>

<p>I found it a helpful extension when working on fixing accessibility issues on the <a href="http://stateoftheservice.apsc.gov.au/">State of Service website</a>. I was able to replicate the voice prompts noted in the accessibility audit. Thus, fixing them was much easier!</p>

<p>One thing to note is that you&rsquo;ll want to change the default voice. The default just seems to cackle at you. You can do this via <code>Settings &gt; Extensions &gt; ChromeVox &gt; Options</code>.</p>
</div><div class="tags"><a href="/tags/accessibility">accessibility</a></div><h1><a href="/cloudfront-origin-pull-with-gzip/">Using CloudFront as ‘origin pull’ (with bonus gzip)</a></h1><div class="content" data-view-highlight=""><p>CloudFront can act as a CDN that ‘pulls’ content from an origin server. It’s really easy to set up, you simply set the ‘Origin Domain Name’ to wherever you’re hosting your app: <code>foobar.herokuapp.com</code> for example and then &hellip; nothing. That’s all you need to do. Requests that come through CloudFront will pass through to your origin server and then be cached thereafter.</p>

<p>For bonus points it’ll also gzip your content for you without you having to do much work at all. Set ‘Compress Objects Automatically’ to ‘Yes’ and you’re done. If CloudFront can serve a gzipped version (and the client can receive one) it’ll serve up a compressed version of your file instead.</p>
</div><div class="tags"><a href="/tags/performance">performance</a>, <a href="/tags/aws">aws</a></div><h1><a href="/async-set-state/">In React setState is not "guaranteed" to be synchronous.</a></h1><div class="content" data-view-highlight=""><p>I discovered recently that if you do something link this in react:</p>

<pre><code class="javascript">this.setState(reallyUseful: true);

if (this.state.reallyUseful) {
  this.doSomethingAmazing();
}
</code></pre>

<p>&hellip; it&rsquo;s not very useful and more often than not nothing amazing happens, just confusion and sadness.</p>

<p>This is because <code>setState</code> it turns out, is asynchronous. Of course most of the time you are doing your amazing things in your render function so everything is sweet but on the odd occasion that you need to pass that value elsewhere, eg: publishing an event, beware!</p>

<p>From the docs:</p>

<blockquote>
<p>setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value.<br>
There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.</p>
</blockquote>

<p>Read about <code>setState</code> here: <a href="https://facebook.github.io/react/docs/component-api.html">https://facebook.github.io/react/docs/component-api.html</a></p>
</div><div class="tags"><a href="/tags/react">react</a>, <a href="/tags/js">js</a></div><h1><a href="/symbolize-keys/">Symbolize keys</a></h1><div class="content" data-view-highlight=""><p>If you&rsquo;re writing plain old Ruby you can symbolize the keys of a hash with the following:</p>

<p><code>hash.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}</code></p>

<p>This does the following:</p>

<pre><code>hash = {&quot;hello&quot; =&gt; &quot;jojo&quot;}
hash.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
=&gt; {:hello=&gt;&quot;jojo&quot;}
</code></pre>

<p>However if you&rsquo;re doing this in a web application you may want to make a module to make hash and array data transformations easily available to you. In most of our apps we would use <a href="https://github.com/solnic/transproc">transproc</a> to help us with this — if you&rsquo;re working in one of Icelab&rsquo;s Rodakase apps this will be available to you.</p>

<pre><code>require &quot;transproc/all&quot;

module Functions
  extend Transproc::Registry

  import Transproc::HashTransformations
  import Transproc::ArrayTransformations

  def self.t(*args)
    self[*args]
  end
end

Functions.t(:symbolize_keys)[{&quot;foo&quot; =&gt; &quot;bar&quot;}]
# =&gt; {foo: &quot;bar&quot;}
</code></pre>

<p>If you are using Rails then you can use the method <code>hash.symbolize_keys</code> or the destructive version <code>hash.symbolize_keys!</code><br>
(both made available via ActiveSupport).</p>
</div><div class="tags"><a href="/tags/ruby">ruby</a></div><h1><a href="/pry-is-amazing/">Pry is amazing</a></h1><div class="content" data-view-highlight=""><p><a href="https://github.com/pry/pry">Pry</a> is amazing! It has a whole bunch of helpful shortcuts you can use while working in a session.</p>

<p>I found the <a href="https://github.com/pry/pry/wiki/Exceptions">exception handling shortcuts</a> particularly helpful. <code>_ex_</code> will give you the last raised exception, and <code>wtf?</code> will show you a stacktrace from that exception (which is helpful, since stacktraces aren&rsquo;t normally shown in interactive terminal sessions like this). Hilariously, you can add more question marks or exclamation marks on the end to see more detail.</p>

<p>If you work with Ruby app consoles regularly, you&rsquo;d do yourself a favour to give the <a href="https://github.com/pry/pry/wiki">Pry Wiki</a> a good read!</p>
</div><div class="tags"><a href="/tags/ruby">ruby</a>, <a href="/tags/debugging">debugging</a></div><h1><a href="/aws-elasticsearch-authentication/">Authenticating with AWS Elasticsearch</a></h1><div class="content" data-view-highlight=""><p>The AWS Elasticseach service offers authentication via an IAM user, or by whitelisting IPs.</p>

<p>Here&rsquo;s how to use IAM credentials to sign requests to the service when using Faraday and how to hook that into the Ruby elasticsearch gem.</p>

<p>To sign requests using Faraday, you can use a gem called <a href="https://github.com/winebarrel/faraday_middleware-aws-signers-v4">faraday_middleware-aws-signers-v4</a>, which provides a middleware that will sign your requests.</p>

<pre><code class="ruby">require &#39;faraday_middleware&#39;
require &#39;faraday_middleware/aws_signers_v4&#39;

conn = Faraday.new(url: &#39;address-of-your-AWS-es-service&#39;) do |faraday|
  faraday.request :aws_signers_v4, {
    credentials: Aws::Credentials.new(ENV[&#39;AWS_ACCESS_KEY_ID&#39;], ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;]),
    service_name: &#39;es&#39;,
    region: &#39;ap-southeast-2&#39;
  }

  faraday.adapter :typhoeus
end
</code></pre>

<p>To get the client provided by the elasticsearch gem to use your Faraday configuation, you can pass that configuration to it like so:</p>

<pre><code class="ruby">faraday_config = lambda do |faraday|
  faraday.request :aws_signers_v4, {
    credentials: Aws::Credentials.new(
      ENV[&quot;ELASTICSEARCH_AWS_ACCESS_KEY_ID&quot;],
      ENV[&quot;ELASTICSEARCH_AWS_SECRET_ACCESS_KEY&quot;]
      ),
      service_name: &quot;es&quot;,
      region: ENV[&quot;ELASTICSEARCH_AWS_REGION&quot;]
    }
    faraday.adapter :typhoeus
  end

elasticsearch_host_config = {
  host:   ENV[&quot;ELASTICSEARCH_HOST&quot;],
  port:   ENV[&quot;ELASTICSEARCH_PORT&quot;],
  scheme: ENV[&quot;ELASTICSEARCH_SCHEME&quot;]
}

transport = Elasticsearch::Transport::Transport::HTTP::Faraday.new(hosts: [elasticsearch_host_config], &amp;faraday_config)

client = Elasticsearch::Client.new(transport: transport)
</code></pre>

<p>You can then use the client object as usual, and you&rsquo;ll get automatically signed requests.</p>
</div><div class="tags"><a href="/tags/ruby">ruby</a>, <a href="/tags/aws">aws</a></div><h1><a href="/using-arel-to-compare-attributes-of-a-record/">Using Arel to compare attributes of a record</a></h1><div class="content" data-view-highlight=""><p>I was just trying to find a way to run a query and compare the <code>updated_at</code> and <code>created_at</code> attributes of a record and came across this technique:</p>

<pre><code class="ruby">users = User.arel_table
User.where(users[:created_at].eq(users[:updated_at]))
</code></pre>

<p>It seems like <code>.gt</code> and <code>.lt</code> also work. While <code>User.where(&quot;created_at = updated_at&quot;)</code> would also work in SQL, we can use Arel to be database agnostic.</p>

<p><em><a href="https://github.com/rails/arel">Arel docs</a></em></p>
</div><div class="tags"><a href="/tags/rails">rails</a></div><h1><a href="/manually-incrementing-count-columns/">Manually incrementing count columns in rails</a></h1><div class="content" data-view-highlight=""><p>Adding a counter cache column to a model is a common optimisation we make in order to avoid unnecessary queries when trying to aggregate data associated with that particular model. Rails provides us with a number of ways to maintain the counter cache column&rsquo;s value. The first is to follow the rails convention and add <code>counter_cache: true</code> to a <code>belongs_to</code> association and ensure we have a correctly named <code>*_count</code> column.</p>

<p>The other way to do it, is manually. In this case rails provides us with a few convenience methods to increment a given column.</p>

<p>The first is <code>ActiveRecord::Base#increment!(attribute, by)</code>.</p>

<p><code>increment!</code> is defined as:</p>

<pre><code class="ruby">def increment!(attribute, by = 1)
  increment(attribute, by).update_attribute(attribute, self[attribute])
end
</code></pre>

<p>and <code>increment</code> is defined as:</p>

<pre><code class="ruby">def increment(attribute, by = 1)
  self[attribute] ||= 0
  self[attribute] += by
  self
end
</code></pre>

<p>Which means that we&rsquo;re first fetching the current attribute&rsquo;s value, incrementing it then passing it on to <code>update_attribute</code> before it can be saved. This method leads to a non-atomic database operation, that is to say that at one point, the count is different in memory than it is in the database (which can lead to race conditions).</p>

<p>The second is <code>ActiveRecord::Base#increment_counter(column_name, record_id)</code>.</p>

<p><code>increment_counter</code> is defined as:</p>

<pre><code class="ruby">def increment_counter(counter_name, id)
  update_counters(id, counter_name =&gt; 1)
end
</code></pre>

<p>which executes SQL like:</p>

<pre><code class="SQL">UPDATE &quot;table_name&quot;
  SET &quot;counter_name&quot; = &quot;counter_name&quot; + 1
  WHERE id = 1
</code></pre>

<p>This means that we now have an atomic operation and the counter cache value is the same across the system.</p>

<p>Docs:</p>

<ul>
<li><em><a href="http://apidock.com/rails/ActiveRecord/Base/increment!">increment!</a></em></li>
<li><em>[increment_counter](<a href="http://apidock.com/rails/ActiveRecord/Base/increment">http://apidock.com/rails/ActiveRecord/Base/increment</a></em>counter/class)_</li>
</ul>
</div><div class="tags"><a href="/tags/rails">rails</a>, <a href="/tags/ruby">ruby</a></div><h1><a href="/using-viewloader-with-turbolinks/">Using viewloader with turbolinks</a></h1><div class="content" data-view-highlight=""><p>When using viewloader with turbolinks, you want to make sure that viewloader executes once on the initial page load, once when the visitor reaches another page, and once when the visitor goes back in their browser (or forward for that matter).</p>

<p>To achieve this, get viewloader to execute on the <code>ready</code>, <code>page:load</code> and <code>page:restore</code> events:</p>

<pre><code class="javascript">$(document).on(&quot;ready page:load page:restore&quot;, function() {
  viewloader.execute(views);
});
</code></pre>

<p><code>page:restore</code> is fired by <a href="https://github.com/rails/turbolinks">turbolinks</a> whenever &ldquo;A cached body element has been loaded into the DOM&rdquo;.</p>
</div><div class="tags"><a href="/tags/js">js</a></div></div><p>Page 1 of 3</p><a href="/page/2/">Next page</a><div class="tags"><h2>All tags</h2><a href="/tags/react">react</a><a href="/tags/js">js</a><a href="/tags/ruby">ruby</a><a href="/tags/aws">aws</a><a href="/tags/accessibility">accessibility</a><a href="/tags/social">social</a><a href="/tags/performance">performance</a><a href="/tags/git">git</a><a href="/tags/css">css</a><a href="/tags/rails">rails</a><a href="/tags/slim">slim</a><a href="/tags/seo">seo</a><a href="/tags/postgres">postgres</a><a href="/tags/debugging">debugging</a><a href="/tags/testing">testing</a><a href="/tags/processing">processing</a></div></body></html>